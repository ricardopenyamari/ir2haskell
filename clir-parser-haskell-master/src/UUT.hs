
-- This file has been generated by the CAVI-ART CLIR-to-Haskell transformer tool


module UUT where


import qualified DataStructures.Arrays as A
import qualified DataStructures.Bags as B
import qualified DataStructures.Sets as S
import qualified DataStructures.Sequences as Q
import DataStructures.Assertion





uutPrec x m a = evalA $
  And
    (FTerm (Aplic
              (Aplic
                 (TVar (<=))
                 ((TConst 0)))
              ((TVar m))))
    (And
       (FTerm (Aplic
                 (Aplic
                    (TVar (<))
                    ((TVar m)))
                 (Aplic
                    ((TVar A.len)) ((TVar a)))))
       (Forall
          (GuardIntTuple
             (Tuple2 ((TConst 0)) ((TConst 0)))
             (Tuple2 (Aplic (Aplic (TVar (-)) (TVar m)) (TConst 1)) (Aplic (Aplic (TVar (-)) (TVar m)) (TConst 1))))
          (\(i, j) -> (Imp
                         (FTerm (Aplic
                                   (Aplic
                                      (TVar (<=))
                                      ((TConst 0)))
                                   ((TVar i))))
                         (Imp
                            (FTerm (Aplic
                                      (Aplic
                                         (TVar (<=))
                                         ((TVar i)))
                                      ((TVar j))))
                            (Imp
                               (FTerm (Aplic
                                         (Aplic
                                            (TVar (<))
                                            ((TVar j)))
                                         ((TVar m))))
                               (FTerm (Aplic
                                         (Aplic
                                            (TVar (<=))
                                            (Aplic
                                               (Aplic
                                                  ((TVar A.get)) ((TVar a))) ((TVar i))))
                                         (Aplic
                                            (Aplic
                                               ((TVar A.get)) ((TVar a))) ((TVar j)))))))))))
insert x m a =
  let i = (-) m 1 in
    f2 x m i a
    where
      f2 x m i a =
        let b1 = (>=) i 0 in
          case b1 of
            False -> f4 x m i a
            True -> let e = A.get a i in
              let b2 = (<) x e in
                case b2 of
                  True -> let e = A.get a i in
                    let i2 = (+) i 1 in
                      let ap = A.set a i2 e in
                        let i3 = (-) i 1 in
                          f2 x m i3 ap
                  False -> f4 x m i a
      f4 x m i a =
        let i2 = (+) i 1 in
          let ap = A.set a i2 x in
            ap
uutPost x m a res = evalA $
  Forall
    (GuardIntTuple
       (Tuple2 ((TConst 0)) ((TConst 0)))
       (Tuple2 ((TVar m)) ((TVar m))))
    (\(i, j) -> (Imp
                   (FTerm (Aplic
                             (Aplic
                                (TVar (<=))
                                ((TConst 0)))
                             ((TVar i))))
                   (Imp
                      (FTerm (Aplic
                                (Aplic
                                   (TVar (<=))
                                   ((TVar i)))
                                ((TVar j))))
                      (Imp
                         (FTerm (Aplic
                                   (Aplic
                                      (TVar (<=))
                                      ((TVar j)))
                                   ((TVar m))))
                         (FTerm (Aplic
                                   (Aplic
                                      (TVar (<=))
                                      (Aplic
                                         (Aplic
                                            ((TVar A.get)) ((TVar res))) ((TVar i))))
                                   (Aplic
                                      (Aplic
                                         ((TVar A.get)) ((TVar res))) ((TVar j)))))))))

